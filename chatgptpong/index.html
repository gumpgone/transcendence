<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Pong — Défi: 35 min</title>
  <style>
    :root{ --bg:#0b1220; --fg:#e6eef8; --accent:#4fd1c5; }
    html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, Roboto, "Helvetica Neue", Arial; background:var(--bg); color:var(--fg); display:flex; align-items:center; justify-content:center}
    .wrap{width:900px; max-width:96vw; aspect-ratio:16/9; background:linear-gradient(180deg, rgba(255,255,255,0.02), transparent); border-radius:12px; box-shadow:0 10px 30px rgba(2,6,23,0.6); padding:14px; display:flex; flex-direction:column}
    header{display:flex; align-items:center; justify-content:space-between; gap:12px}
    h1{font-size:18px;margin:0}
    .meta{font-size:13px; color:rgba(230,238,248,0.7)}
    canvas{background:transparent; width:100%; height:100%; border-radius:8px; display:block}
    .controls{display:flex; gap:8px; align-items:center}
    button{background:var(--accent); color:#022; border:none; padding:8px 12px; border-radius:8px; font-weight:600; cursor:pointer}
    .hud{display:flex; gap:10px; align-items:center}
    .kbd{font-size:12px; color:var(--fg); background:rgba(255,255,255,0.03); padding:6px 8px; border-radius:6px}
    footer{display:flex; justify-content:space-between; align-items:center; margin-top:8px}
    .note{font-size:12px; color:rgba(230,238,248,0.65)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>Pong — Démonstration (fait par ChatGPT)</h1>
        <div class="meta">Montre à Greg qu'il s'était trompé — jouable immédiatement</div>
      </div>
      <div class="controls">
        <div class="hud">
          <div class="kbd">W/S</div>
          <div class="meta" style="margin-left:6px">Joueur gauche</div>
        </div>
        <div class="hud">
          <div class="kbd">↑/↓</div>
          <div class="meta" style="margin-left:6px">Joueur droit</div>
        </div>
        <button id="startBtn">Démarrer / Rejouer</button>
      </div>
    </header>

    <div style="flex:1; margin-top:10px; position:relative">
      <canvas id="game"></canvas>
    </div>

    <footer>
      <div class="note">But : 7 points — appuie sur espace pour mettre en pause. Appuie 'A' pour activer l'IA droite.</div>
      <div class="note">Astuce: sauvegarde ce fichier localement comme <code>pong.html</code> et ouvre-le dans ton navigateur.</div>
    </footer>
  </div>

  <script>
  // Pong simple — complet, indépendant et commenté
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // sizes responsive
  function resize() {
    const rect = canvas.getBoundingClientRect();
    canvas.width = rect.width * devicePixelRatio;
    canvas.height = rect.height * devicePixelRatio;
    ctx.setTransform(devicePixelRatio,0,0,devicePixelRatio,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // Game state
  const state = {
    paused: true,
    leftScore: 0,
    rightScore: 0,
    maxScore: 7,
    aiRight: false
  }

  const field = { w: 800, h: 450, padW:10 };
  // Convert logical coordinates to canvas coordinates (we scale to fit)
  function scaleX(x){ return x * (canvas.clientWidth / field.w); }
  function scaleY(y){ return y * (canvas.clientHeight / field.h); }

  // Objects
  const paddle = (x) => ({ x, y: field.h/2 - 40, w: 10, h: 80, speed: 6 });
  const left = paddle(20);
  const right = paddle(field.w - 30);

  const ball = { x: field.w/2, y: field.h/2, r:8, speed:6, velX: 6, velY: 2 };

  // Control input
  const keys = {};
  window.addEventListener('keydown', e=>{ keys[e.key.toLowerCase()] = true; if(e.code==='Space'){ state.paused = !state.paused; } if(e.key.toLowerCase()==='a'){ state.aiRight = !state.aiRight } });
  window.addEventListener('keyup', e=>{ keys[e.key.toLowerCase()] = false });

  // Start / reset
  document.getElementById('startBtn').addEventListener('click', start);
  function resetBall(direction=1){
    ball.x = field.w/2; ball.y = field.h/2;
    const angle = (Math.random() * Math.PI/3) - Math.PI/6; // -30°..30°
    const speed = 6;
    ball.speed = speed;
    ball.velX = Math.cos(angle) * speed * direction;
    ball.velY = Math.sin(angle) * speed;
  }
  function start(){ state.leftScore = 0; state.rightScore = 0; resetBall(Math.random()<0.5?1:-1); state.paused=false }
  resetBall( Math.random()<0.5?1:-1 );

  // Update loop
  function update(){
    if(!state.paused){
      // left paddle controls W/S
      if(keys['w']) left.y -= left.speed;
      if(keys['s']) left.y += left.speed;
      // right paddle controls Up/Down unless AI active
      if(!state.aiRight){ if(keys['arrowup']) right.y -= right.speed; if(keys['arrowdown']) right.y += right.speed; }
      else{
        // simple AI: follow ball with easing
        const center = right.y + right.h/2;
        const diff = ball.y - center;
        right.y += Math.sign(diff) * Math.min(Math.abs(diff)*0.12, right.speed);
      }

      // clamp
      left.y = Math.max(0, Math.min(field.h - left.h, left.y));
      right.y = Math.max(0, Math.min(field.h - right.h, right.y));

      // move ball
      ball.x += ball.velX;
      ball.y += ball.velY;

      // top/bottom collisions
      if(ball.y - ball.r < 0){ ball.y = ball.r; ball.velY *= -1 }
      if(ball.y + ball.r > field.h){ ball.y = field.h - ball.r; ball.velY *= -1 }

      // paddle collisions
      function collidePaddle(p){
        if(ball.x - ball.r < p.x + p.w && ball.x + ball.r > p.x && ball.y + ball.r > p.y && ball.y - ball.r < p.y + p.h){
          // reflect
          const relative = (ball.y - (p.y + p.h/2)) / (p.h/2); // -1..1
          const bounce = relative * (Math.PI/4); // max 45°
          const direction = (p === left) ? 1 : -1;
          const speedIncrease = 0.3;
          ball.speed = Math.min(12, ball.speed + speedIncrease);
          ball.velX = Math.cos(bounce) * ball.speed * direction;
          ball.velY = Math.sin(bounce) * ball.speed;
          // push ball outside paddle to avoid repeated collision
          if(p === left) ball.x = p.x + p.w + ball.r + 0.1;
          else ball.x = p.x - ball.r - 0.1;
        }
      }
      collidePaddle(left); collidePaddle(right);

      // scoring
      if(ball.x < -50){ state.rightScore++; resetBall(1); state.paused = false; }
      if(ball.x > field.w + 50){ state.leftScore++; resetBall(-1); state.paused = false; }

      // win check
      if(state.leftScore >= state.maxScore || state.rightScore >= state.maxScore){
        state.paused = true;
      }
    }
  }

  // render
  function drawRoundedRect(x,y,w,h,r){
    ctx.beginPath(); ctx.moveTo(x+r,y); ctx.arcTo(x+w,y,x+w,y+h,r); ctx.arcTo(x+w,y+h,x,y+h,r); ctx.arcTo(x,y+h,x,y,r); ctx.arcTo(x,y,x+w,y,r); ctx.closePath(); ctx.fill();
  }

  function render(){
    // clear
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // scale to logical field size
    const sx = canvas.clientWidth/field.w;
    const sy = canvas.clientHeight/field.h;
    ctx.save();
    ctx.scale(sx, sy);

    // background
    ctx.fillStyle = 'rgba(255,255,255,0.02)';
    drawRoundedRect(0,0,field.w,field.h,8);

    // center line
    ctx.strokeStyle = 'rgba(255,255,255,0.08)'; ctx.lineWidth = 2;
    ctx.setLineDash([8,12]); ctx.beginPath(); ctx.moveTo(field.w/2,20); ctx.lineTo(field.w/2,field.h-20); ctx.stroke(); ctx.setLineDash([]);

    // paddles
    ctx.fillStyle = '#e6eef8';
    ctx.fillRect(left.x, left.y, left.w, left.h);
    ctx.fillRect(right.x, right.y, right.w, right.h);

    // ball
    ctx.beginPath(); ctx.fillStyle = '#4fd1c5'; ctx.arc(ball.x, ball.y, ball.r, 0, Math.PI*2); ctx.fill();

    // scores and HUD
    ctx.fillStyle = 'rgba(230,238,248,0.95)'; ctx.font = '24px system-ui'; ctx.textAlign = 'center';
    ctx.fillText(state.leftScore, field.w*0.25, 40);
    ctx.fillText(state.rightScore, field.w*0.75, 40);

    // paused / winner overlay
    if(state.paused){
      ctx.fillStyle = 'rgba(2,6,23,0.6)'; ctx.fillRect(field.w*0.12, field.h*0.3, field.w*0.76, field.h*0.35);
      ctx.fillStyle = '#e6eef8'; ctx.font = '20px system-ui'; ctx.textAlign='center';
      if(state.leftScore >= state.maxScore || state.rightScore >= state.maxScore){
        const winner = state.leftScore > state.rightScore ? 'Joueur gauche gagne !' : 'Joueur droit gagne !';
        ctx.fillText(winner, field.w/2, field.h*0.45);
        ctx.font = '16px system-ui'; ctx.fillText('Appuie sur Démarrer pour rejouer', field.w/2, field.h*0.55);
      } else {
        ctx.fillText('PAUSE', field.w/2, field.h*0.45);
        ctx.font = '16px system-ui'; ctx.fillText("Appuie sur Démarrer (ou espace) pour continuer. Appuie 'A' pour activer l'IA droite.", field.w/2, field.h*0.55);
      }
    }

    ctx.restore();
  }

  // main loop using requestAnimationFrame
  let last = performance.now();
  function loop(now){
    const dt = now - last;
    last = now;
    // cap updates to 60fps physics
    update();
    render();
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  // helpful: let user click/tap to toggle pause
  canvas.addEventListener('click', ()=> state.paused = !state.paused);

  // make it responsive initially
  setTimeout(resize, 50);
  </script>
</body>
</html>

